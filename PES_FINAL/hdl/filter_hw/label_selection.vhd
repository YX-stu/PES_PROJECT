library ieee;
use ieee.std_logic_1164.all;

-- arithmetic functions with signed or unsigned values
use ieee.numeric_std.all;

library axi_filter_dma_v1_00_a;
use axi_filter_dma_v1_00_a.all;

--! This component implements the label selection and region detection algorithm based on the runs generated by the run-length encoder.

--! Inputs are the runs generated by the run-length encoder. The results are stored in an internal BRAM which can be read out using the
--! #FEATURE_BRAM_READOUT and #FEATURE_BRAM_RADDR ports.
--!
--! @see rle
--! @see region_detect
entity label_selection is
  generic(
        ROW_LENGTH                  : positive; --! Length of a row in the input image
        ROW_LENGTH_WIDTH            : positive; --! Bitwidth of #ROW_LENGTH
        NUMBER_OF_ROWS              : positive; --! Number of rows in the input image
        ROW_NUMBER_WIDTH            : positive; --! Bitwidth of #NUMBER_OF_ROWS
        MAX_NUMBER_LABELS           : positive; --! Maximum number of supported labels
        FEATURE_BRAM_ADDR_WIDTH     : positive; --! Address width for the BRAM holding the detected regions
        NUMBER_ROWS_BRAM            : positive := 3; --! The number of rows that need to be buffered in a BRAM in order to cache previously detected runs.
    SIMULATION                  : std_logic := '0'  --! Simulation mode
    );
  port(
        clk                         : in std_logic; --! cLock input
        rstn                        : in std_logic; --! nEgated asynchronous reset
        start_pos                   : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! Start pos of the currently detected run. @see rle.start_pos
        end_pos                     : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! End pos of the currently detected run. @see rle.end_pos
        row_number                  : in std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0); --! Row number of the currently detected run. @see rle.row_number
        new_run                     : in std_logic; --! iNdicates whether a new run is available on #START_POS, #END_POS and #ROW_NUMBER. @see rle.new_run
        eol                         : in std_logic; --! iNdicates if the run-length encoder has reached the end of a row in the image. @see rle.eol
        eof                         : in std_logic; --! iNdicates if the run-length encoder has reached the end of the data stream.  @see rle.eof
        feature_bram_readout        : in std_logic; --! eNables the feature BRAM readout. Should only be set to '1' if all image processing steps have been completed (#IDLE = '1').
        feature_bram_raddr          : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0); --! Read addres for the feature BRAM
        feature_bram_left_border    : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! Left border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_right_border   : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0); --! Right border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_upper_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0); --! Upper border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_lower_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0); --! Lower border of the feature stored at the current BRAM address #FEATURE_BRAM_RADDR
        feature_bram_valid          : out std_logic; --! indicates if the feature at the current BRAM address #FEATURE_BRAM_RADDR is valid. Invalid features should be ignored.
        feature_bram_count          : out std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0); --! Outputs the total number of features in the BRAM. The value of #FEATURE_BRAM_RADDR should always be lower than this number.
        idle                        : out std_logic --! Indicates whether the component is IDLE (i.e. all image data has been processed completely)

    );
end label_selection;

architecture behavioral of label_selection is

function getAddrWidthBram return positive is    --calculates the size of the BRAM
    variable addrWidth : positive := 1;
    variable tmp : positive;
    variable tmp_res : positive;
begin
    tmp_res := ROW_LENGTH * NUMBER_ROWS_BRAM;
    tmp := 2;
    while tmp < tmp_res loop
        tmp := tmp * 2;
        addrWidth := addrWidth + 1;
    end loop;
    return addrWidth;
end function getAddrWidthBram;

component ram_tp is
    generic (

        ADDR_WIDTH      : positive := 2;
        DATA_WIDTH      : positive := 6;
        USE_OUTPUT_REG  : std_logic := '0'
    );
    port (
        clk             : in std_logic;
        w_addr          : in std_logic_vector(ADDR_WIDTH-1 downto 0);
        w_data          : in std_logic_vector(DATA_WIDTH-1 downto 0);
        w_enable        : in std_logic;
        r_addr_1        : in std_logic_vector(ADDR_WIDTH-1 downto 0);
        r_data_1        : out std_logic_vector(DATA_WIDTH-1 downto 0);
        r_addr_2        : in std_logic_vector(ADDR_WIDTH-1 downto 0);
        r_data_2        : out std_logic_vector(DATA_WIDTH-1 downto 0)
    );
    end component;


    component  feature_label_check is
    generic(
        ROW_LENGTH_WIDTH            : positive := 10;
        ROW_NUMBER_WIDTH            : positive := 9;
        FEATURE_BRAM_ADDR_WIDTH     : positive := 11
    );
    port(       
		clk                         : in std_logic;
        rstn                        : in std_logic;

        new_feature                 : in std_logic;
        update                      : in std_logic;
        merge                       : in std_logic;
        run_label_1                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        run_label_2                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        start_pos                   : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        end_pos                     : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        row_number                  : in std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);

        feature_bram_readout        : in std_logic;
        feature_bram_raddr          : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        feature_bram_left_border    : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_right_border   : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_upper_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_lower_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_valid          : out std_logic
    );
    end component;

    component feature_calculation is
    generic(
        ROW_LENGTH                  : positive := 640;
        ROW_LENGTH_WIDTH            : positive := 10;
        NUMBER_OF_ROWS              : positive := 480;
        ROW_NUMBER_WIDTH            : positive := 9;
        MAX_NUMBER_LABELS           : positive := 2045;
        FEATURE_BRAM_ADDR_WIDTH     : positive := 11
    );
    port(
        clk                         : in std_logic;
        rstn                        : in std_logic;

        new_feature                 : in std_logic;
        update                      : in std_logic;
        merge                       : in std_logic;
        run_label_1                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        run_label_2                 : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        start_pos                   : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        end_pos                     : in std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        row_number                  : in std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);

        feature_bram_readout        : in std_logic;
        feature_bram_raddr          : in std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
        feature_bram_left_border    : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_right_border   : out std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
        feature_bram_upper_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_lower_border   : out std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        feature_bram_valid          : out std_logic
    );
    end component;



    constant ADDR_WIDTH_BRAM : positive := getAddrWidthBram;
    constant MAX_NUMBER_RUNS : positive := 2**ADDR_WIDTH_BRAM;
    constant DATA_WIDTH_BRAM : positive := 2 * ROW_LENGTH_WIDTH + ROW_NUMBER_WIDTH + FEATURE_BRAM_ADDR_WIDTH ;

    signal update_feature, merge_feature, new_feature       : std_logic;
    signal update_feature_label, merge_feature_label        : std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
    signal update_feature_start_pos, update_feature_end_pos : std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
    signal update_feature_row_number                        : std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);

    type RUN_TYPE is
        record
            start_pos   : std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
            end_pos     : std_logic_vector(ROW_LENGTH_WIDTH-1 downto 0);
            run_label   : std_logic_vector(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
            row_number  : std_logic_vector(ROW_NUMBER_WIDTH-1 downto 0);
        end record;

    signal bram_w_addr          : std_logic_vector(ADDR_WIDTH_BRAM-1 downto 0);

    signal w_data_ram           : std_logic_vector(DATA_WIDTH_BRAM-1 downto 0);
    signal bram_read_prev_run   : std_logic_vector(DATA_WIDTH_BRAM-1 downto 0);
    signal bram_read_act_run    : std_logic_vector(DATA_WIDTH_BRAM-1 downto 0);

    signal w_enable             : std_logic;
    signal bram_read_addr_1     : std_logic_vector(ADDR_WIDTH_BRAM-1 downto 0);
    signal bram_read_addr_2     : std_logic_vector(ADDR_WIDTH_BRAM-1 downto 0);
    signal bram_prev_run        : RUN_TYPE;
    signal bram_act_run         : RUN_TYPE;

    -- STUDENT CODE HERE
    -- Pointer for the previous row 
    signal prev_row_run_pointer : integer := 0;
    -- Pointer for the current row 
    signal act_row_run_pointer : integer := 0;
    signal r_act_row_run_pointer : integer := 0;
    -- Pointer for the new coming run
    signal new_run_pointer : integer := 1;
    
    -- Flag of end of line 
    signal eol_label : std_logic := '0';
    -- Flag of end of final flag
    signal eof_label : std_logic := '0';
    -- Delay register(4 clock cycles delay) for three labels
    signal new_feature_del : std_logic_vector(2 downto 0) := (others => '0');
    signal update_feature_del : std_logic_vector(2 downto 0) := (others => '0');
    signal merge_feature_del : std_logic_vector(2 downto 0) := (others => '0');
    
    -- Delay register(4 clock cycles delay) for the starting of comparition between runs
    signal start : std_logic := '0';
    signal start_del : std_logic_vector(3 downto 0) := (others => '0');
    
    -- The status of runs (relative relationships)
    type t_result is (a, b, c, d, e, u, z);
    -- At start the status is unknown u
    signal prev_result : t_result := u;
    
    -- New label for the run after action
    signal new_label: std_logic_vector(FEATURE_BRAM_ADDR_WIDTH - 1 downto 0) := (others => '0');
    -- STUDENT CODE until HERE

begin
    -- STUDENT CODE HERE

    -- STUDENT CODE until HERE

    G_FEATURE_CALCULATION : if SIMULATION = '0' generate
    begin
        feature_calculation_module : feature_calculation
        generic map (
            ROW_LENGTH              => ROW_LENGTH,
            ROW_LENGTH_WIDTH        => ROW_LENGTH_WIDTH,
            NUMBER_OF_ROWS          => NUMBER_OF_ROWS,
            ROW_NUMBER_WIDTH        => ROW_NUMBER_WIDTH,
            MAX_NUMBER_LABELS       => MAX_NUMBER_LABELS,
            FEATURE_BRAM_ADDR_WIDTH => FEATURE_BRAM_ADDR_WIDTH
        )
        port map (
            clk                       => clk,
            rstn                      => rstn,

            run_label_1               => update_feature_label,
            run_label_2               => merge_feature_label,
            start_pos                 => update_feature_start_pos,
            end_pos                   => update_feature_end_pos,
            row_number                => update_feature_row_number,
            update                    => update_feature,
            merge                     => merge_feature,
            new_feature               => new_feature,
            feature_bram_readout      => feature_bram_readout,
            feature_bram_raddr        => feature_bram_raddr,
            feature_bram_left_border  => feature_bram_left_border,
            feature_bram_right_border => feature_bram_right_border,
            feature_bram_upper_border => feature_bram_upper_border,
            feature_bram_lower_border => feature_bram_lower_border,
            feature_bram_valid        => feature_bram_valid
        );
    end generate;

    G_FEATURE_LABEL_CHECK : if SIMULATION = '1' generate
    begin
        feature_label_check_module : feature_label_check
        generic map (
            ROW_LENGTH_WIDTH        => ROW_LENGTH_WIDTH,
            ROW_NUMBER_WIDTH        => ROW_NUMBER_WIDTH,
            FEATURE_BRAM_ADDR_WIDTH => FEATURE_BRAM_ADDR_WIDTH
        )
        port map (
            clk                       => clk,
            rstn                      => rstn,

            run_label_1               => update_feature_label,
            run_label_2               => merge_feature_label,
            start_pos                 => update_feature_start_pos,
            end_pos                   => update_feature_end_pos,
            row_number                => update_feature_row_number,
            update                    => update_feature,
            merge                     => merge_feature,
            new_feature               => new_feature,
            feature_bram_readout      => feature_bram_readout,
            feature_bram_raddr        => feature_bram_raddr,
            feature_bram_left_border  => feature_bram_left_border,
            feature_bram_right_border => feature_bram_right_border,
            feature_bram_upper_border => feature_bram_upper_border,
            feature_bram_lower_border => feature_bram_lower_border,
            feature_bram_valid        => feature_bram_valid
        );
    end generate;


    bram_runs: ram_tp
    generic map (
        ADDR_WIDTH     => ADDR_WIDTH_BRAM,
        DATA_WIDTH     => DATA_WIDTH_BRAM,
        USE_OUTPUT_REG => '1'
    )
    -- Daten im RAM liegen wie folgt vor: start_pos & end_pos & run_label & row_number  ## alles in STD_LOGIC_VECTOR!
    port map (
        clk             => clk,
        w_addr          => bram_w_addr,
        w_data          => w_data_ram,
        w_enable        => w_enable,
        r_addr_1        => bram_read_addr_1,
        r_data_1        => bram_read_prev_run ,
        r_addr_2        => bram_read_addr_2,
        r_data_2        => bram_read_act_run
    );


    -- STUDENT CODE HERE

    -- STUDENT CODE until HERE

    LABEL_SELECTION_Synchron : process(clk, rstn, new_run)
    -- Variable of actual row pointer
--    variable v_act_row_runpointer      : integer range 0 to (2**(ROW_LENGTH_WIDTH+ROW_NUMBER_WIDTH))-1 := 0;
    -- Once execution for every run
    variable once : std_logic := '0';
    -- From status d to status a, b, c, e
    variable once_for_a : std_logic := '0';
    variable once_for_b : std_logic := '0';
    variable once_for_c : std_logic := '0';
    variable once_for_e : std_logic := '0';
    -- Flag of openning for the comparision between runs
    variable v_start : std_logic := '0';
    -- Flag of updating prev_run_pointer or act_run_pointer
    variable update_b_a : std_logic := '0';
    variable update_b_others : std_logic := '0';
    variable update_c_a : std_logic := '0';
    variable update_c_others : std_logic := '0';
    variable update_e_ab : std_logic := '0';
    variable update_e_others : std_logic := '0';
    -- Calculate the numver of line
--    variable line_counter : integer ;
--    variable curr_addr : std_logic_vector (ADDR_WIDTH_BRAM - 1 downto 0);
    
    begin
        bram_read_addr_1 <= std_logic_vector(to_unsigned(prev_row_run_pointer, ADDR_WIDTH_BRAM));
        bram_read_addr_2 <= std_logic_vector(to_unsigned(act_row_run_pointer, ADDR_WIDTH_BRAM));
        if rstn = '0' then
            -- STUDENT CODE HERE
            -- Ininitialization of output
            -- feature_bram_left_border    <= (others => '0');
            -- feature_bram_right_border   <= (others => '0');
            -- feature_bram_upper_border   <= (others => '0');
            -- feature_bram_lower_border   <= (others => '0');
            -- feature_bram_valid          <= '0';
--            idle                   <= '0';
            
            -- Initialization of signal
            update_feature_label <= (others => '0');
            merge_feature_label  <= (others => '0');  
            update_feature_start_pos <= (others => '0');
            update_feature_end_pos <= (others => '0');
            update_feature_row_number <= (others => '0');     
            update_feature        <= '0';
            merge_feature         <= '0';
            new_feature           <= '0';
            
            start <= '0';
            start_del <= (others => '0');
            
            w_enable <= '0';
            bram_w_addr <= std_logic_vector(to_unsigned(1, ADDR_WIDTH_BRAM));
            bram_read_addr_1 <= (others => '0');
            bram_read_addr_2 <= (others => '0');
            
            prev_row_run_pointer <= 0;
            act_row_run_pointer <= 0;
            r_act_row_run_pointer <= 0;
            new_run_pointer <= 1;
            new_label <= (others => '0');
            
            prev_result <= u; 
--            line_counter := 0;
            -- Ininitialization of varaible
            once := '0';
            once_for_a := '0';
            once_for_b := '0';
            once_for_c := '0';
            once_for_e := '0';
            update_b_a := '0';
            update_b_others := '0';
            update_c_a := '0';
            update_c_others := '0';
            update_e_ab := '0';
            update_e_others := '0';
            
            v_start := '0';
            
            -- STUDENT CODE until HERE

            bram_prev_run.start_pos    <= (others => '0');
            bram_prev_run.end_pos      <= (others => '0');
            bram_prev_run.run_label    <= (others => '0');
            bram_prev_run.row_number   <= (others => '0');

            bram_act_run.start_pos     <= (others => '0');
            bram_act_run.end_pos       <= (others => '0');
            bram_act_run.run_label     <= (others => '0');
            bram_act_run.row_number    <= (others => '0');

    --  w_data_ram_tmp <= (others => '0';

        elsif rising_edge(clk) then

            bram_prev_run.start_pos  <= bram_read_prev_run(DATA_WIDTH_BRAM - 1 downto DATA_WIDTH_BRAM - ROW_LENGTH_WIDTH);
            bram_prev_run.end_pos    <= bram_read_prev_run(DATA_WIDTH_BRAM - ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH);
            bram_prev_run.run_label  <= bram_read_prev_run(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH);
            bram_prev_run.row_number <= bram_read_prev_run(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH - 1 downto 0);

            bram_act_run.start_pos   <= bram_read_act_run(DATA_WIDTH_BRAM - 1 downto DATA_WIDTH_BRAM - ROW_LENGTH_WIDTH);
            bram_act_run.end_pos     <= bram_read_act_run(DATA_WIDTH_BRAM - ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH);
            bram_act_run.run_label   <= bram_read_act_run(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH);
            bram_act_run.row_number  <= bram_read_act_run(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH - 1 downto 0);

            -- STUDENT CODE HERE 
            -- Update the act_run_pointer
            act_row_run_pointer <= r_act_row_run_pointer;
            
            -- One clock delay of eol
            if eof = '1' then
                eof_label <= '1';
            end if;
            -- All image data has been processed completely
            if eof_label = '1' then
                idle <= '1';
                -- Change the status to idle 
                prev_result <= z;
                v_start := '0';
                eof_label <= '0';
            end if;
            
            -- Delay for starting
            start_del(0) <= '0';
            for i in 0 to 2 loop
                start_del(i+1) <= start_del(i);
            end loop;
            start <= start_del(3);

            -- STUDENT CODE until HERE

            update_feature        <= '0';
            update_feature_del(0) <= '0';
            merge_feature         <= '0';
            merge_feature_del(0)  <= '0';
            new_feature           <= '0';
            new_feature_del(0)    <= '0';
			
			
            if new_run = '1' then
                w_enable <= '1';
                w_data_ram <= start_pos & end_pos & std_logic_vector(to_unsigned(0,FEATURE_BRAM_ADDR_WIDTH)) & row_number;---row_number;

                -- STUDENT CODE HERE
                -- Reset idle, it means open component again
                idle <= '0';
                -- Start the timing
                start_del(0) <= '1';
                -- Close the comparision
                v_start := '0';
                -- Writing address of new run in BRAM
--                if line_counter < 3 then
--				    new_run_pointer <= new_run_pointer + 1;
--				else 
--				    new_run_pointer <= 0;
--				    line_counter := 0;
--				end if;
                new_run_pointer <= new_run_pointer + 1;
				bram_w_addr <= std_logic_vector(to_unsigned(new_run_pointer,ADDR_WIDTH_BRAM));
				
				-- Update the act_run_pointer
                 case prev_result is
                    when a => null;
                    when b =>
                        if update_b_a = '1' then
                            r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                            update_b_a := '0';
                        elsif update_b_others = '1' then
                            r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                            update_b_others := '0';
                        end if;
                    when c =>
                        if update_c_a = '1' then
                            r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                            update_c_a := '0';
                        elsif update_c_others = '1' then
                            r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                            update_c_others := '0';
                        end if;
                    when d => null;
                    when e =>
                        if update_e_ab = '1' then
                            r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                            update_e_ab := '0';
                        elsif update_e_others = '1' then
                            r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                            update_e_others := '0';
                        end if;
                    when u =>
                        --update current run
                        r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                    when others => 
                        --update current run
                        r_act_row_run_pointer <= r_act_row_run_pointer + 1;
                        -- Reset the merge label
                        merge_feature_label <= (others => '0');
                end case;

                -- One new run comes
                once := '1';
                
                -- One clock delay of eol
				if eol = '1' then
					eol_label <= '1';
				end if;
				
            -- Need to wait for the new rum (4 clock cycles)
			elsif new_run = '0' and (start = '1' or v_start = '1') then
			    -- Open the comparision
			    v_start := '1';
			    -- One clock delay of eol
				if eol = '1' then
					eol_label <= '1';
--					line_counter := line_counter + 1;
				end if;
                	
                -- At start we set the initial status u
                -- In the first line, status should be always u 
                -- When there is not valid prev_run data, status is u
                if prev_result = u then
					prev_result <= u;
                    if once = '1' then
                        --assign a new label to current run
                        w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= new_label;
                        --update new label
                        new_label <= std_logic_vector(unsigned(new_label) + 1);
                        -- Give only once the signal
                        new_feature <= '1';
                        once := '0';
                        
                        -- Updata information to feature calculation
                        update_feature_label <= new_label;
                        update_feature_start_pos <= bram_act_run.start_pos;
                        update_feature_end_pos <= bram_act_run.end_pos;
                        update_feature_row_number <= bram_act_run.row_number;
                    end if;
                    if eol_label = '1' then
                        prev_row_run_pointer <= prev_row_run_pointer + 1;
                        eol_label <= '0';
                        -- Change the status to idle 
                        prev_result <= z;
                        v_start := '0';
                    end if;
                    -- After 4 clock cycles data has been transfered to feature_cal
--                    for i in 0 to 1 loop
--                      new_feature_del(i+1) <= new_feature_del(i);
--                    end loop;
--                    new_feature <= new_feature_del(2); 
				
				--current result is d
                -- pre-run and act-run should be both valid
				elsif bram_prev_run.end_pos < bram_act_run.start_pos and prev_result /= u then
                    prev_result <= d;
                    if once = '1' then
                        -- Update previous-row run
                        prev_row_run_pointer <= prev_row_run_pointer + 1;
                        once := '0';
                        once_for_a := '1';
                        once_for_b := '1';
                        once_for_c := '1';
                        once_for_e := '1';
                    end if;      
                    if eol_label='1' then
                        --assign a new label to current run
                        w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= new_label;
                        --update new label
                        new_label <= std_logic_vector(unsigned(new_label) + 1);
                        new_feature <= '1';
                        -- Updata information to feature calculation
                        update_feature_label <= new_label;
                        update_feature_start_pos <= bram_act_run.start_pos;
                        update_feature_end_pos <= bram_act_run.end_pos;
                        update_feature_row_number <= bram_act_run.row_number;
                        
                        prev_row_run_pointer <= prev_row_run_pointer + 1;
                        eol_label <= '0';
                        -- Change the status to idle 
                        prev_result <= z;
                        v_start := '0';
                    end if;
						
				--current result is e
                -- pre-run and act-run should be both valid
				elsif bram_prev_run.start_pos > bram_act_run.end_pos and prev_result /= u then
					prev_result <= e;
					--current result is e and previous result is a,b
					if prev_result = a or prev_result = b then
                        if once = '1' or once_for_e = '1' then
						  -- Flag of updating current run
						  update_e_ab := '1';
						  once := '0';
                          once_for_e := '0';
                        end if;
						if eol_label = '1' then
							prev_row_run_pointer <= prev_row_run_pointer + 1;
							eol_label <= '0';
                            -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
						end if;
						
					--current result is e and previous result is c,d,e
					else
                        if once = '1' or once_for_e = '1' then
                            --assign a new label to current run
                            w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= new_label;
                            --update new label
                            new_label <= std_logic_vector(unsigned(new_label) + 1);
                            -- Flag of updating current run
                            update_e_others := '1';
                            -- Only once 
                            new_feature <= '1';
                            once := '0';
                            once_for_e := '0';
                            
                            -- Updata information to feature calculation
                            update_feature_label <= new_label;
                            update_feature_start_pos <= bram_act_run.start_pos;
                            update_feature_end_pos <= bram_act_run.end_pos;
                            update_feature_row_number <= bram_act_run.row_number;
                        end if;
						if eol_label = '1' then
							prev_row_run_pointer <= prev_row_run_pointer + 1;
							eol_label <= '0';
                            -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
						end if;
--						-- After 4 clock cycles data has been transfered to feature_cal
--						new_feature_del(0) <= '1';
--						for i in 0 to 1 loop
--						  new_feature_del(i+1) <= new_feature_del(i);
--						end loop;
--						new_feature <= new_feature_del(2);
					end if;
						
				--current result is c
				-- pre-run and act-run should be both valid
				elsif bram_prev_run.end_pos = bram_act_run.end_pos and prev_result /= u then
                    prev_result <= c;
                    --current result is c and previous result is a
                    if prev_result = a then
                        
                        if once = '1' or once_for_c = '1' then
                            --update both previous-row and current run
                            prev_row_run_pointer <= prev_row_run_pointer + 1;	
                            -- Flag of updating act_run pointer
                            update_c_a := '1';
                            merge_feature <= '1';
                            once := '0';
                            once_for_c := '0';
                            
                             --previous run label is smaller
                            if bram_prev_run.run_label < bram_act_run.run_label then
                                update_feature_label <= bram_prev_run.run_label;
                                merge_feature_label  <= bram_act_run.run_label;
                                --update current run label to previous run label in ram_tp (assign smaller label to current run)
                                w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_prev_run.run_label;	                    
                            --current run label is smaller
                            else 
                                update_feature_label <= bram_act_run.run_label;
                                merge_feature_label  <= bram_prev_run.run_label;
                                --update previous run label to current run label in ram_tp 
                                w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_act_run.run_label;	                               
                            end if;
                        end if;
                        if eol_label = '1' then
                            eol_label <= '0';
                             -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
                        end if;

                    --current result is c and previous result is others
                    else
                        if once = '1' or once_for_c = '1' then
                            --update both previous-row and current run
                            prev_row_run_pointer <= prev_row_run_pointer + 1;
                            -- Flag of updating act_run pointer
                            update_c_others := '1';	
                            update_feature <= '1';
                            once := '0';
                            once_for_c := '0';
                            once_for_e := '1';
                            
                            --update current run label to previous run label
                            w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_prev_run.run_label;
                            -- Updata information to feature calculation
                            update_feature_label <= bram_prev_run.run_label;
                            update_feature_start_pos <= bram_act_run.start_pos;
                            update_feature_end_pos <= bram_act_run.end_pos;
                            update_feature_row_number <= bram_act_run.row_number;
                        end if;
                        if eol_label = '1' then
                            eol_label <= '0';
                            -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
                        end if;
                    end if;
							
				--current result is a
				-- pre-run and act-run should be both valid
				elsif bram_prev_run.end_pos < bram_act_run.end_pos and bram_prev_run.end_pos >= bram_act_run.start_pos then
                    prev_result <= a;
                    --curent result is a and previous result is a
                    if prev_result = a then
                        if once = '1' or once_for_a = '1' then
                            prev_row_run_pointer <= prev_row_run_pointer + 1;
                            --previous run label is smaller
                            if bram_prev_run.run_label < bram_act_run.run_label then
                                update_feature_label <= bram_prev_run.run_label;
                                merge_feature_label  <= bram_act_run.run_label;
                                --update current run label to previous run label in ram_tp (assign smaller label to current run)
                                w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_prev_run.run_label;	
                            --current run label is smaller
                            else 
                                update_feature_label <= bram_act_run.run_label;
                                merge_feature_label  <= bram_prev_run.run_label;
                                --update previous run label to current run label in ram_tp 
                                w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_act_run.run_label;								
                            end if;
                            merge_feature <= '1';
                            once := '0';
                            once_for_a := '0';
                        end if;
                        if eol_label = '1' then
                            eol_label <= '0';
                            act_row_run_pointer <= act_row_run_pointer + 1;
                            -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
                        end if;

                    --current result is a and previous result is others
                    else
                        if once = '1' and once_for_a = '1' then
                            prev_row_run_pointer <= prev_row_run_pointer + 1;
                            --update current run label to previous run label
                            w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_prev_run.run_label;
                            update_feature <= '1';
                            once := '0';
                            once_for_a := '0';
                            once_for_b := '1';
                            once_for_c := '1';
                            once_for_e := '1';
                            
                            -- Updata information to feature calculation
                            update_feature_label <= bram_prev_run.run_label;
                            update_feature_start_pos <= bram_act_run.start_pos;
                            update_feature_end_pos <= bram_act_run.end_pos;
                            update_feature_row_number <= bram_act_run.row_number;
                        end if;
                        if eol_label='1' then
                            eol_label <= '0';
                            act_row_run_pointer <= act_row_run_pointer + 1;
                            -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
                        end if;
                    end if;
				
				--current result is b
				-- pre-run and act-run should be both valid
				elsif bram_prev_run.end_pos > bram_act_run.end_pos and bram_prev_run.start_pos <= bram_act_run.end_pos then
                    prev_result <= b;
                    --current result is b and previous result is a
                    if prev_result = a then
                        if once = '1' or once_for_b = '1' then
                            -- Flag of updating current run
                            update_b_a := '1';
                            merge_feature <= '1';
                            once := '0';
                            once_for_b := '0';
                            
                            --previous run label is smaller
                            if bram_prev_run.run_label < bram_act_run.run_label then
                                update_feature_label <= bram_prev_run.run_label;
                                merge_feature_label  <= bram_act_run.run_label;
                                --update current run label to previous run label in ram_tp (assign smaller label to current run)
                                w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_prev_run.run_label;	
                                
                            --current run label is smaller
                            else 
                                update_feature_label <= bram_act_run.run_label;
                                merge_feature_label  <= bram_prev_run.run_label;
                                --update previous run label to current run label in ram_tp 
                                w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_act_run.run_label;	                                  
                            end if;
                        end if;
                    
                        if eol_label = '1' then
                            eol_label <= '0';
                            prev_row_run_pointer <= prev_row_run_pointer + 1;
                            -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
                        end if;
                    
                    --current result is b and previous result is others					
                    else
                        if eol_label='1' then
                            eol_label <= '0';
                            prev_row_run_pointer <= prev_row_run_pointer + 1;
                            -- Change the status to idle 
                            prev_result <= z;
                            v_start := '0';
                        end if;
                        if once = '1' or once_for_b = '1' then
                            -- Flag of update current run
                            update_b_others := '1';
                            --update current run label to previous run label
                            w_data_ram(DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - 1 downto DATA_WIDTH_BRAM - 2*ROW_LENGTH_WIDTH - FEATURE_BRAM_ADDR_WIDTH) <= bram_prev_run.run_label;
                            update_feature <= '1';
                            once := '0';
                            once_for_b := '0';
                            once_for_e := '1';
                            
                            -- Updata information to feature calculation
                            update_feature_label <= bram_prev_run.run_label;
                            update_feature_start_pos <= bram_act_run.start_pos;
                            update_feature_end_pos <= bram_act_run.end_pos;
                            update_feature_row_number <= bram_act_run.row_number;
                        end if;
--                        -- After 4 clock cycles data has been transfered to feature_cal
--                        for i in 0 to 1 loop
--                            update_feature_del(i+1) <= update_feature_del(i);
--                        end loop;
--                        update_feature <= update_feature_del(2);
                            
                    end if;
				end if;			
                -- STUDENT CODE until HERE
            end if;
        end if;
    end process;

    -- STUDENT CODE HERE
    -- Calculate the total number of features
	Calculate_number_of_features : process(clk, rstn, new_feature, update_feature, merge_feature)
		variable feature_counter : unsigned(FEATURE_BRAM_ADDR_WIDTH-1 downto 0);
		begin
			if rstn = '0' then
                feature_bram_count <= (others => '0');
				feature_counter := (others => '0');
			elsif rising_edge(clk) and new_feature = '1' then
				feature_counter := feature_counter + 1;
			elsif rising_edge(clk) and update_feature = '1' then
				feature_counter := feature_counter;
			elsif rising_edge(clk) and merge_feature = '1' then
				feature_counter := feature_counter - 1;
			end if;
			feature_bram_count <= std_logic_vector(feature_counter);
	end process;
    -- STUDENT CODE until HERE


end behavioral;

